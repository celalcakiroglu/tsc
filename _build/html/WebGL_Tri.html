<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Polygon Meshing through Triangulation &mdash; Tensile Strain Capacity 1.0.2 documentation</title>
    
    <link rel="stylesheet" href="_static/default.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '1.0.2',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="top" title="Tensile Strain Capacity 1.0.2 documentation" href="index.html" />
    <link rel="next" title="Dual N-Back with Geometry and Tunes" href="WebGL_DNBackShapes.html" />
    <link rel="prev" title="3D Modeling Tutorials" href="SiemensNX.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="WebGL_DNBackShapes.html" title="Dual N-Back with Geometry and Tunes"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="SiemensNX.html" title="3D Modeling Tutorials"
             accesskey="P">previous</a> |</li>
        <li><a href="index.html">Tensile Strain Capacity 1.0.2 documentation</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="polygon-meshing-through-triangulation">
<h1>Polygon Meshing through Triangulation<a class="headerlink" href="#polygon-meshing-through-triangulation" title="Permalink to this headline">Â¶</a></h1>
<head>
   <meta charset="utf-8" />
   <title>Draw a blue rectangle (canvas version)</title>
</head>
<body onload="listen()">
   <canvas id="webgl" width ="650" height="650">
   Use html supporting browser
   </canvas>
   <p>
       <button id="bDefine" type="button">BOUNDARY DEFINED</button>
       <button id="reDefine" type="button">REDEFINE BOUNDARY</button>
   </p>
   How many interior points? <input type="text" id="iPoints">
   <button id="iPointsApply" type="button">Apply</button>
   <script>
     function listen(){
     main();
     }
   </script>
   <script>
      /*
      * Copyright 2010, Google Inc.
      * All rights reserved.
      *
      * Redistribution and use in source and binary forms, with or without
      * modification, are permitted provided that the following conditions are
      * met:
      *
      *     * Redistributions of source code must retain the above copyright
      * notice, this list of conditions and the following disclaimer.
      *     * Redistributions in binary form must reproduce the above
      * copyright notice, this list of conditions and the following disclaimer
      * in the documentation and/or other materials provided with the
      * distribution.
      *     * Neither the name of Google Inc. nor the names of its
      * contributors may be used to endorse or promote products derived from
      * this software without specific prior written permission.
      *
      * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
      * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
      * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
      * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
      * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
      * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
      * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
      * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
      * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
      * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
      * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
      */
      /**
      * @fileoverview This file contains functions every webgl program will need
      * a version of one way or another.
      *
      * Instead of setting up a context manually it is recommended to
      * use. This will check for success or failure. On failure it
      * will attempt to present an approriate message to the user.
      *
      *       gl = WebGLUtils.setupWebGL(canvas);
      *
      * For animated WebGL apps use of setTimeout or setInterval are
      * discouraged. It is recommended you structure your rendering
      * loop like this.
      *
      *       function render() {
      *         window.requestAnimFrame(render, canvas);
      *
      *         // do rendering
      *         ...
      *       }
      *       render();
      *
      * This will call your rendering function up to the refresh rate
      * of your display but will stop rendering if your app is not
      * visible.
      */
      WebGLUtils = function() {
      /**
      * Creates the HTLM for a failure message
      * @param {string} canvasContainerId id of container of th
      *        canvas.
      * @return {string} The html.
      */
      var makeFailHTML = function(msg) {
      return '' +
         '<table style="background-color: #8CE; width: 100%; height: 100%;"><tr>' +
         '<td align="center">' +
         '<div style="display: table-cell; vertical-align: middle;">' +
         '<div style="">' + msg + '</div>' +
         '</div>' +
         '</td></tr></table>';
      };
      /**
      * Mesasge for getting a webgl browser
      * @type {string}
      */
      var GET_A_WEBGL_BROWSER = '' +
      'This page requires a browser that supports WebGL.<br/>' +
      '<a href="http://get.webgl.org">Click here to upgrade your browser.</a>';
      /**
      * Mesasge for need better hardware
      * @type {string}
      */
      var OTHER_PROBLEM = '' +
      "It doesn't appear your computer can support WebGL.<br/>" +
      '<a href="http://get.webgl.org/troubleshooting/">Click here for more information.         </a>';
      /**
      * Creates a webgl context. If creation fails it will
      * change the contents of the container of the <canvas>
      * tag to an error message with the correct links for WebGL.
      * @param {Element} canvas. The canvas element to create a
      *     context from.
      * @param {WebGLContextCreationAttirbutes} opt_attribs Any
      *     creation attributes you want to pass in.
      * @param {function:(msg)} opt_onError An function to call
      *     if there is an error during creation.
      * @return {WebGLRenderingContext} The created context.
      */
      var setupWebGL = function(canvas, opt_attribs, opt_onError) {
      function handleCreationError(msg) {
         var container = canvas.parentNode;
         if (container) {
            var str = window.WebGLRenderingContext ?
               OTHER_PROBLEM :
               GET_A_WEBGL_BROWSER;
            if (msg) {
            str += "<br/><br/>Status: " + msg;
            }
            container.innerHTML = makeFailHTML(str);
         }
      };
      opt_onError = opt_onError || handleCreationError;
      if (canvas.addEventListener) {
         canvas.addEventListener("webglcontextcreationerror", function(event) {
               opt_onError(event.statusMessage);
            }, false);
      }
      var context = create3DContext(canvas, opt_attribs);
      if (!context) {
         if (!window.WebGLRenderingContext) {
            opt_onError("");
         }
      }
      return context;
      };
      /**
      * Creates a webgl context.
      * @param {!Canvas} canvas The canvas tag to get context
      *     from. If one is not passed in one will be created.
      * @return {!WebGLContext} The created context.
      */
      var create3DContext = function(canvas, opt_attribs) {
      var names = ["webgl", "experimental-webgl", "webkit-3d", "moz-webgl"];
      var context = null;
      for (var ii = 0; ii < names.length; ++ii) {
         try {
            context = canvas.getContext(names[ii], opt_attribs);
         } catch(e) {}
         if (context) {
            break;
         }
      }
      return context;
      }
      return {
      create3DContext: create3DContext,
      setupWebGL: setupWebGL
      };
      }();
      /**
      * Provides requestAnimationFrame in a cross browser way.
      */
      window.requestAnimFrame = (function() {
      return window.requestAnimationFrame ||
               window.webkitRequestAnimationFrame ||
               window.mozRequestAnimationFrame ||
               window.oRequestAnimationFrame ||
               window.msRequestAnimationFrame ||
               function(/* function FrameRequestCallback */ callback, /* DOMElement Element */ element) {
               window.setTimeout(callback, 1000/60);
               };
      })();
   </script>
   <script>
      //Copyright (c) 2009 The Chromium Authors. All rights reserved.
      //Use of this source code is governed by a BSD-style license that can be
      //found in the LICENSE file.

      // Various functions for helping debug WebGL apps.

      WebGLDebugUtils = function() {

      /**
       * Wrapped logging function.
       * @param {string} msg Message to log.
       */
      var log = function(msg) {
        if (window.console && window.console.log) {
          window.console.log(msg);
        }
      };

      /**
       * Which arguements are enums.
       * @type {!Object.<number, string>}
       */
      var glValidEnumContexts = {

        // Generic setters and getters

        'enable': { 0:true },
        'disable': { 0:true },
        'getParameter': { 0:true },

        // Rendering

        'drawArrays': { 0:true },
        'drawElements': { 0:true, 2:true },

        // Shaders

        'createShader': { 0:true },
        'getShaderParameter': { 1:true },
        'getProgramParameter': { 1:true },

        // Vertex attributes

        'getVertexAttrib': { 1:true },
        'vertexAttribPointer': { 2:true },

        // Textures

        'bindTexture': { 0:true },
        'activeTexture': { 0:true },
        'getTexParameter': { 0:true, 1:true },
        'texParameterf': { 0:true, 1:true },
        'texParameteri': { 0:true, 1:true, 2:true },
        'texImage2D': { 0:true, 2:true, 6:true, 7:true },
        'texSubImage2D': { 0:true, 6:true, 7:true },
        'copyTexImage2D': { 0:true, 2:true },
        'copyTexSubImage2D': { 0:true },
        'generateMipmap': { 0:true },

        // Buffer objects

        'bindBuffer': { 0:true },
        'bufferData': { 0:true, 2:true },
        'bufferSubData': { 0:true },
        'getBufferParameter': { 0:true, 1:true },

        // Renderbuffers and framebuffers

        'pixelStorei': { 0:true, 1:true },
        'readPixels': { 4:true, 5:true },
        'bindRenderbuffer': { 0:true },
        'bindFramebuffer': { 0:true },
        'checkFramebufferStatus': { 0:true },
        'framebufferRenderbuffer': { 0:true, 1:true, 2:true },
        'framebufferTexture2D': { 0:true, 1:true, 2:true },
        'getFramebufferAttachmentParameter': { 0:true, 1:true, 2:true },
        'getRenderbufferParameter': { 0:true, 1:true },
        'renderbufferStorage': { 0:true, 1:true },

        // Frame buffer operations (clear, blend, depth test, stencil)

        'clear': { 0:true },
        'depthFunc': { 0:true },
        'blendFunc': { 0:true, 1:true },
        'blendFuncSeparate': { 0:true, 1:true, 2:true, 3:true },
        'blendEquation': { 0:true },
        'blendEquationSeparate': { 0:true, 1:true },
        'stencilFunc': { 0:true },
        'stencilFuncSeparate': { 0:true, 1:true },
        'stencilMaskSeparate': { 0:true },
        'stencilOp': { 0:true, 1:true, 2:true },
        'stencilOpSeparate': { 0:true, 1:true, 2:true, 3:true },

        // Culling

        'cullFace': { 0:true },
        'frontFace': { 0:true },
      };

      /**
       * Map of numbers to names.
       * @type {Object}
       */
      var glEnums = null;

      /**
       * Initializes this module. Safe to call more than once.
       * @param {!WebGLRenderingContext} ctx A WebGL context. If
       *    you have more than one context it doesn't matter which one
       *    you pass in, it is only used to pull out constants.
       */
      function init(ctx) {
        if (glEnums == null) {
          glEnums = { };
          for (var propertyName in ctx) {
            if (typeof ctx[propertyName] == 'number') {
              glEnums[ctx[propertyName]] = propertyName;
            }
          }
        }
      }

      /**
       * Checks the utils have been initialized.
       */
      function checkInit() {
        if (glEnums == null) {
          throw 'WebGLDebugUtils.init(ctx) not called';
        }
      }

      /**
       * Returns true or false if value matches any WebGL enum
       * @param {*} value Value to check if it might be an enum.
       * @return {boolean} True if value matches one of the WebGL defined enums
       */
      function mightBeEnum(value) {
        checkInit();
        return (glEnums[value] !== undefined);
      }

      /**
       * Gets an string version of an WebGL enum.
       *
       * Example:
       *   var str = WebGLDebugUtil.glEnumToString(ctx.getError());
       *
       * @param {number} value Value to return an enum for
       * @return {string} The string version of the enum.
       */
      function glEnumToString(value) {
        checkInit();
        var name = glEnums[value];
        return (name !== undefined) ? name :
            ("*UNKNOWN WebGL ENUM (0x" + value.toString(16) + ")");
      }

      /**
       * Returns the string version of a WebGL argument.
       * Attempts to convert enum arguments to strings.
       * @param {string} functionName the name of the WebGL function.
       * @param {number} argumentIndx the index of the argument.
       * @param {*} value The value of the argument.
       * @return {string} The value as a string.
       */
      function glFunctionArgToString(functionName, argumentIndex, value) {
        var funcInfo = glValidEnumContexts[functionName];
        if (funcInfo !== undefined) {
          if (funcInfo[argumentIndex]) {
            return glEnumToString(value);
          }
        }
        return value.toString();
      }

      /**
       * Given a WebGL context returns a wrapped context that calls
       * gl.getError after every command and calls a function if the
       * result is not gl.NO_ERROR.
       *
       * @param {!WebGLRenderingContext} ctx The webgl context to
       *        wrap.
       * @param {!function(err, funcName, args): void} opt_onErrorFunc
       *        The function to call when gl.getError returns an
       *        error. If not specified the default function calls
       *        console.log with a message.
       */
      function makeDebugContext(ctx, opt_onErrorFunc) {
        init(ctx);
        opt_onErrorFunc = opt_onErrorFunc || function(err, functionName, args) {
              // apparently we can't do args.join(",");
              var argStr = "";
              for (var ii = 0; ii < args.length; ++ii) {
                argStr += ((ii == 0) ? '' : ', ') +
                    glFunctionArgToString(functionName, ii, args[ii]);
              }
              log("WebGL error "+ glEnumToString(err) + " in "+ functionName +
                  "(" + argStr + ")");
            };

        // Holds booleans for each GL error so after we get the error ourselves
        // we can still return it to the client app.
        var glErrorShadow = { };

        // Makes a function that calls a WebGL function and then calls getError.
        function makeErrorWrapper(ctx, functionName) {
          return function() {
            var result = ctx[functionName].apply(ctx, arguments);
            var err = ctx.getError();
            if (err != 0) {
              glErrorShadow[err] = true;
              opt_onErrorFunc(err, functionName, arguments);
            }
            return result;
          };
        }

        // Make a an object that has a copy of every property of the WebGL context
        // but wraps all functions.
        var wrapper = {};
        for (var propertyName in ctx) {
          if (typeof ctx[propertyName] == 'function') {
             wrapper[propertyName] = makeErrorWrapper(ctx, propertyName);
           } else {
             wrapper[propertyName] = ctx[propertyName];
           }
        }

        // Override the getError function with one that returns our saved results.
        wrapper.getError = function() {
          for (var err in glErrorShadow) {
            if (glErrorShadow[err]) {
              glErrorShadow[err] = false;
              return err;
            }
          }
          return ctx.NO_ERROR;
        };

        return wrapper;
      }

      function resetToInitialState(ctx) {
        var numAttribs = ctx.getParameter(ctx.MAX_VERTEX_ATTRIBS);
        var tmp = ctx.createBuffer();
        ctx.bindBuffer(ctx.ARRAY_BUFFER, tmp);
        for (var ii = 0; ii < numAttribs; ++ii) {
          ctx.disableVertexAttribArray(ii);
          ctx.vertexAttribPointer(ii, 4, ctx.FLOAT, false, 0, 0);
          ctx.vertexAttrib1f(ii, 0);
        }
        ctx.deleteBuffer(tmp);

        var numTextureUnits = ctx.getParameter(ctx.MAX_TEXTURE_IMAGE_UNITS);
        for (var ii = 0; ii < numTextureUnits; ++ii) {
          ctx.activeTexture(ctx.TEXTURE0 + ii);
          ctx.bindTexture(ctx.TEXTURE_CUBE_MAP, null);
          ctx.bindTexture(ctx.TEXTURE_2D, null);
        }

        ctx.activeTexture(ctx.TEXTURE0);
        ctx.useProgram(null);
        ctx.bindBuffer(ctx.ARRAY_BUFFER, null);
        ctx.bindBuffer(ctx.ELEMENT_ARRAY_BUFFER, null);
        ctx.bindFramebuffer(ctx.FRAMEBUFFER, null);
        ctx.bindRenderbuffer(ctx.RENDERBUFFER, null);
        ctx.disable(ctx.BLEND);
        ctx.disable(ctx.CULL_FACE);
        ctx.disable(ctx.DEPTH_TEST);
        ctx.disable(ctx.DITHER);
        ctx.disable(ctx.SCISSOR_TEST);
        ctx.blendColor(0, 0, 0, 0);
        ctx.blendEquation(ctx.FUNC_ADD);
        ctx.blendFunc(ctx.ONE, ctx.ZERO);
        ctx.clearColor(0, 0, 0, 0);
        ctx.clearDepth(1);
        ctx.clearStencil(-1);
        ctx.colorMask(true, true, true, true);
        ctx.cullFace(ctx.BACK);
        ctx.depthFunc(ctx.LESS);
        ctx.depthMask(true);
        ctx.depthRange(0, 1);
        ctx.frontFace(ctx.CCW);
        ctx.hint(ctx.GENERATE_MIPMAP_HINT, ctx.DONT_CARE);
        ctx.lineWidth(1);
        ctx.pixelStorei(ctx.PACK_ALIGNMENT, 4);
        ctx.pixelStorei(ctx.UNPACK_ALIGNMENT, 4);
        ctx.pixelStorei(ctx.UNPACK_FLIP_Y_WEBGL, false);
        ctx.pixelStorei(ctx.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);
        // TODO: Delete this IF.
        if (ctx.UNPACK_COLORSPACE_CONVERSION_WEBGL) {
          ctx.pixelStorei(ctx.UNPACK_COLORSPACE_CONVERSION_WEBGL, ctx.BROWSER_DEFAULT_WEBGL);
        }
        ctx.polygonOffset(0, 0);
        ctx.sampleCoverage(1, false);
        ctx.scissor(0, 0, ctx.canvas.width, ctx.canvas.height);
        ctx.stencilFunc(ctx.ALWAYS, 0, 0xFFFFFFFF);
        ctx.stencilMask(0xFFFFFFFF);
        ctx.stencilOp(ctx.KEEP, ctx.KEEP, ctx.KEEP);
        ctx.viewport(0, 0, ctx.canvas.clientWidth, ctx.canvas.clientHeight);
        ctx.clear(ctx.COLOR_BUFFER_BIT | ctx.DEPTH_BUFFER_BIT | ctx.STENCIL_BUFFER_BIT);

        // TODO: This should NOT be needed but Firefox fails with 'hint'
        while(ctx.getError());
      }

      function makeLostContextSimulatingContext(ctx) {
        var wrapper_ = {};
        var contextId_ = 1;
        var contextLost_ = false;
        var resourceId_ = 0;
        var resourceDb_ = [];
        var onLost_ = undefined;
        var onRestored_ = undefined;
        var nextOnRestored_ = undefined;

        // Holds booleans for each GL error so can simulate errors.
        var glErrorShadow_ = { };

        function isWebGLObject(obj) {
          //return false;
          return (obj instanceof WebGLBuffer ||
                  obj instanceof WebGLFramebuffer ||
                  obj instanceof WebGLProgram ||
                  obj instanceof WebGLRenderbuffer ||
                  obj instanceof WebGLShader ||
                  obj instanceof WebGLTexture);
        }

        function checkResources(args) {
          for (var ii = 0; ii < args.length; ++ii) {
            var arg = args[ii];
            if (isWebGLObject(arg)) {
              return arg.__webglDebugContextLostId__ == contextId_;
            }
          }
          return true;
        }

        function clearErrors() {
          var k = Object.keys(glErrorShadow_);
          for (var ii = 0; ii < k.length; ++ii) {
            delete glErrorShdow_[k];
          }
        }

        // Makes a function that simulates WebGL when out of context.
        function makeLostContextWrapper(ctx, functionName) {
          var f = ctx[functionName];
          return function() {
            // Only call the functions if the context is not lost.
            if (!contextLost_) {
              if (!checkResources(arguments)) {
                glErrorShadow_[ctx.INVALID_OPERATION] = true;
                return;
              }
              var result = f.apply(ctx, arguments);
              return result;
            }
          };
        }

        for (var propertyName in ctx) {
          if (typeof ctx[propertyName] == 'function') {
             wrapper_[propertyName] = makeLostContextWrapper(ctx, propertyName);
           } else {
             wrapper_[propertyName] = ctx[propertyName];
           }
        }

        function makeWebGLContextEvent(statusMessage) {
          return {statusMessage: statusMessage};
        }

        function freeResources() {
          for (var ii = 0; ii < resourceDb_.length; ++ii) {
            var resource = resourceDb_[ii];
            if (resource instanceof WebGLBuffer) {
              ctx.deleteBuffer(resource);
            } else if (resource instanceof WebctxFramebuffer) {
              ctx.deleteFramebuffer(resource);
            } else if (resource instanceof WebctxProgram) {
              ctx.deleteProgram(resource);
            } else if (resource instanceof WebctxRenderbuffer) {
              ctx.deleteRenderbuffer(resource);
            } else if (resource instanceof WebctxShader) {
              ctx.deleteShader(resource);
            } else if (resource instanceof WebctxTexture) {
              ctx.deleteTexture(resource);
            }
          }
        }

        wrapper_.loseContext = function() {
          if (!contextLost_) {
            contextLost_ = true;
            ++contextId_;
            while (ctx.getError());
            clearErrors();
            glErrorShadow_[ctx.CONTEXT_LOST_WEBGL] = true;
            setTimeout(function() {
                if (onLost_) {
                  onLost_(makeWebGLContextEvent("context lost"));
                }
              }, 0);
          }
        };

        wrapper_.restoreContext = function() {
          if (contextLost_) {
            if (onRestored_) {
              setTimeout(function() {
                  freeResources();
                  resetToInitialState(ctx);
                  contextLost_ = false;
                  if (onRestored_) {
                    var callback = onRestored_;
                    onRestored_ = nextOnRestored_;
                    nextOnRestored_ = undefined;
                    callback(makeWebGLContextEvent("context restored"));
                  }
                }, 0);
            } else {
              throw "You can not restore the context without a listener"
            }
          }
        };

        // Wrap a few functions specially.
        wrapper_.getError = function() {
          if (!contextLost_) {
            var err;
            while (err = ctx.getError()) {
              glErrorShadow_[err] = true;
            }
          }
          for (var err in glErrorShadow_) {
            if (glErrorShadow_[err]) {
              delete glErrorShadow_[err];
              return err;
            }
          }
          return ctx.NO_ERROR;
        };

        var creationFunctions = [
          "createBuffer",
          "createFramebuffer",
          "createProgram",
          "createRenderbuffer",
          "createShader",
          "createTexture"
        ];
        for (var ii = 0; ii < creationFunctions.length; ++ii) {
          var functionName = creationFunctions[ii];
          wrapper_[functionName] = function(f) {
            return function() {
              if (contextLost_) {
                return null;
              }
              var obj = f.apply(ctx, arguments);
              obj.__webglDebugContextLostId__ = contextId_;
              resourceDb_.push(obj);
              return obj;
            };
          }(ctx[functionName]);
        }

        var functionsThatShouldReturnNull = [
          "getActiveAttrib",
          "getActiveUniform",
          "getBufferParameter",
          "getContextAttributes",
          "getAttachedShaders",
          "getFramebufferAttachmentParameter",
          "getParameter",
          "getProgramParameter",
          "getProgramInfoLog",
          "getRenderbufferParameter",
          "getShaderParameter",
          "getShaderInfoLog",
          "getShaderSource",
          "getTexParameter",
          "getUniform",
          "getUniformLocation",
          "getVertexAttrib"
        ];
        for (var ii = 0; ii < functionsThatShouldReturnNull.length; ++ii) {
          var functionName = functionsThatShouldReturnNull[ii];
          wrapper_[functionName] = function(f) {
            return function() {
              if (contextLost_) {
                return null;
              }
              return f.apply(ctx, arguments);
            }
          }(wrapper_[functionName]);
        }

        var isFunctions = [
          "isBuffer",
          "isEnabled",
          "isFramebuffer",
          "isProgram",
          "isRenderbuffer",
          "isShader",
          "isTexture"
        ];
        for (var ii = 0; ii < isFunctions.length; ++ii) {
          var functionName = isFunctions[ii];
          wrapper_[functionName] = function(f) {
            return function() {
              if (contextLost_) {
                return false;
              }
              return f.apply(ctx, arguments);
            }
          }(wrapper_[functionName]);
        }

        wrapper_.checkFramebufferStatus = function(f) {
          return function() {
            if (contextLost_) {
              return ctx.FRAMEBUFFER_UNSUPPORTED;
            }
            return f.apply(ctx, arguments);
          };
        }(wrapper_.checkFramebufferStatus);

        wrapper_.getAttribLocation = function(f) {
          return function() {
            if (contextLost_) {
              return -1;
            }
            return f.apply(ctx, arguments);
          };
        }(wrapper_.getAttribLocation);

        wrapper_.getVertexAttribOffset = function(f) {
          return function() {
            if (contextLost_) {
              return 0;
            }
            return f.apply(ctx, arguments);
          };
        }(wrapper_.getVertexAttribOffset);

        wrapper_.isContextLost = function() {
          return contextLost_;
        };

        function wrapEvent(listener) {
          if (typeof(listener) == "function") {
            return listener;
          } else {
            return function(info) {
              listener.handleEvent(info);
            }
          }
        }

        wrapper_.registerOnContextLostListener = function(listener) {
          onLost_ = wrapEvent(listener);
        };

        wrapper_.registerOnContextRestoredListener = function(listener) {
          if (contextLost_) {
            nextOnRestored_ = wrapEvent(listener);
          } else {
            onRestored_ = wrapEvent(listener);
          }
        }

        return wrapper_;
      }

      return {
        /**
         * Initializes this module. Safe to call more than once.
         * @param {!WebGLRenderingContext} ctx A WebGL context. If
         *    you have more than one context it doesn't matter which one
         *    you pass in, it is only used to pull out constants.
         */
        'init': init,

        /**
         * Returns true or false if value matches any WebGL enum
         * @param {*} value Value to check if it might be an enum.
         * @return {boolean} True if value matches one of the WebGL defined enums
         */
        'mightBeEnum': mightBeEnum,

        /**
         * Gets an string version of an WebGL enum.
         *
         * Example:
         *   WebGLDebugUtil.init(ctx);
         *   var str = WebGLDebugUtil.glEnumToString(ctx.getError());
         *
         * @param {number} value Value to return an enum for
         * @return {string} The string version of the enum.
         */
        'glEnumToString': glEnumToString,

        /**
         * Converts the argument of a WebGL function to a string.
         * Attempts to convert enum arguments to strings.
         *
         * Example:
         *   WebGLDebugUtil.init(ctx);
         *   var str = WebGLDebugUtil.glFunctionArgToString('bindTexture', 0, gl.TEXTURE_2D);
         *
         * would return 'TEXTURE_2D'
         *
         * @param {string} functionName the name of the WebGL function.
         * @param {number} argumentIndx the index of the argument.
         * @param {*} value The value of the argument.
         * @return {string} The value as a string.
         */
        'glFunctionArgToString': glFunctionArgToString,

        /**
         * Given a WebGL context returns a wrapped context that calls
         * gl.getError after every command and calls a function if the
         * result is not NO_ERROR.
         *
         * You can supply your own function if you want. For example, if you'd like
         * an exception thrown on any GL error you could do this
         *
         *    function throwOnGLError(err, funcName, args) {
         *      throw WebGLDebugUtils.glEnumToString(err) + " was caused by call to" +
         *            funcName;
         *    };
         *
         *    ctx = WebGLDebugUtils.makeDebugContext(
         *        canvas.getContext("webgl"), throwOnGLError);
         *
         * @param {!WebGLRenderingContext} ctx The webgl context to wrap.
         * @param {!function(err, funcName, args): void} opt_onErrorFunc The function
         *     to call when gl.getError returns an error. If not specified the default
         *     function calls console.log with a message.
         */
        'makeDebugContext': makeDebugContext,

        /**
         * Given a WebGL context returns a wrapped context that adds 4
         * functions.
         *
         * ctx.loseContext:
         *   simulates a lost context event.
         *
         * ctx.restoreContext:
         *   simulates the context being restored.
         *
         * ctx.registerOnContextLostListener(listener):
         *   lets you register a listener for context lost. Use instead
         *   of addEventListener('webglcontextlostevent', listener);
         *
         * ctx.registerOnContextRestoredListener(listener):
         *   lets you register a listener for context restored. Use
         *   instead of addEventListener('webglcontextrestored',
         *   listener);
         *
         * @param {!WebGLRenderingContext} ctx The webgl context to wrap.
         */
        'makeLostContextSimulatingContext': makeLostContextSimulatingContext,

        /**
         * Resets a context to the initial state.
         * @param {!WebGLRenderingContext} ctx The webgl context to
         *     reset.
         */
        'resetToInitialState': resetToInitialState
      };

      }();
   </script>
   <script>
      function initShaders(gl, vshader, fshader) {
      var program = createProgram(gl, vshader, fshader);
      if (!program) {
      console.log('failed to create program');
      return false;
      }
      gl.useProgram(program);
      gl.program = program;
      return true;
      }

      function createProgram(gl, vshader, fshader) {

      var vertexShader = loadShader(gl, gl.VERTEX_SHADER, vshader);
      var fragmentShader = loadShader(gl, gl.FRAGMENT_SHADER, fshader);
      if (!vertexShader || !fragmentShader) {
      return null;
      }

      var program = gl.createProgram();
      if (!program) {
      return null;
      }

      gl.attachShader(program, vertexShader);
      gl.attachShader(program, fragmentShader);

      gl.linkProgram(program);

      var linked = gl.getProgramParameter(program, gl.LINK_STATUS);
      if (!linked) {
      var error = gl.getProgramInfoLog(program);
      console.log('failed to link program: ' + error);
      gl.deleteProgram(program);
      gl.deleteShader(fragmentShader);
      gl.deleteShader(vertexShader);
      return null;
      }
      return program;
      }

      function loadShader(gl, type, source) {

      var shader = gl.createShader(type);
      if (shader == null) {
      console.log('unable to create shader');
      return null;
      }

      gl.shaderSource(shader, source);

      gl.compileShader(shader);

      var compiled = gl.getShaderParameter(shader, gl.COMPILE_STATUS);
      if (!compiled) {
      var error = gl.getShaderInfoLog(shader);
      console.log('failed to compile shader: ' + error);
      gl.deleteShader(shader);
      return null;
      }
      return shader;
      }

      function loadVariableLocations(gl, program) {
      var i, name;

      var attribCount = gl.getProgramParameter(program, gl.ACTIVE_ATTRIBUTES);
      var uniformCount = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);

      var attribIndex = {};
      for (i = 0; i < attribCount; ++i) {
      name = gl.getActiveAttrib(program, i).name;
      attribIndex[name] = i;
      }

      var uniformLoc = {};
      for (i = 0; i < uniformCount; ++i) {
      name = gl.getActiveUniform(program, i).name;
      uniformLoc[name] = gl.getUniformLocation(program, name);
      }

      program.attribIndex = attribIndex;
      program.uniformLoc = uniformLoc;
      }

      function getWebGLContext(canvas, opt_debug) {
      var gl = WebGLUtils.setupWebGL(canvas);
      if (!gl) return null;
      if (arguments.length < 2 || opt_debug) {
      gl = WebGLDebugUtils.makeDebugContext(gl);
      }
      return gl;
      }
   </script>
   <script>
      //Vertex shader program
       var VSHADER_SOURCE=
       //Add an attribute here for clicking mode and
       //Boundary drawing mode
       //Then write an if condition inside the shader
       'attribute vec4 a_Position;\n'+
       'void main(){\n'+
       'gl_Position=a_Position;\n'+
       'gl_PointSize=5.0;\n'+
       '}\n';
       //Fragment shader Program
       var FSHADER_SOURCE=
       'precision mediump float;\n'+
       //'uniform vec4 u_FragColor;\n'+
       'void main(){\n'+
       'gl_FragColor=vec4(1.0, 0.0, 0.0, 1.0);\n'+
       '}\n';

       var b_coords=new Float32Array(300);//boundary points
       var i_coords=new Float32Array(600);//interior points
       var n_coords=new Float32Array(900);//all points
       var bDefined=false;//The boundary isn't defined yet
       var nCoords=0;//Number of vertex coordinates (total)
       var bCoords=0;//Number of boundary coordinates
       var iCoords=0;//Number of interior coordinates
       var nInteriorPts;//Number of interior vertices
       var nBoundaryPts;//Number of boundary vertices
       var nPts;//Total number of vertices
       function main(){
         var canvas = document.getElementById('webgl');
         var bDefineBtn=document.getElementById('bDefine');
         var reDefineBtn=document.getElementById('reDefine');
         var iPointsTxt=document.getElementById('iPoints');
         var iPointsBtn=document.getElementById('iPointsApply');
         var gl=getWebGLContext(canvas);
         if(!gl){
           console.log('Failed to get the rendering context for WebGL');
           return;
         }
         else{console.log('success getting the rendering context');}
         if(!initShaders(gl, VSHADER_SOURCE, FSHADER_SOURCE)){
           console.log('Failed to initialize shaders');
           return;
         }
         else{console.log('success initializing the shaders');}
         canvas.onmousedown=function(ev){click(ev, gl, canvas)};
         bDefineBtn.onclick=function(ev){bDefine(ev,gl)};//Make sure this syntax is correct
         reDefineBtn.onclick=function(ev){reDefine(ev,gl)};//Make sure this syntax is correct
         iPointsBtn.onclick=function(ev){iPoints(ev,gl,iPointsTxt)};
         gl.clearColor(0.78,0.87,0.88,1.0);//blueish grey
         gl.clear(gl.COLOR_BUFFER_BIT);
       }

       function click(ev, gl, canvas){
         if(bDefined==false){
             var x = ev.clientX;
             var y = ev.clientY;
             var rect=ev.target.getBoundingClientRect();//Gets the position of canvas in the client area
             x=((x-rect.left)-canvas.width/2)/(canvas.width/2);
             y=(canvas.height/2-(y-rect.top))/(canvas.height/2);
             console.log('in click x= '+x+' y= '+y);
             b_coords[bCoords]=x;n_coords[bCoords]=x;
             b_coords[bCoords+1]=y;n_coords[bCoords+1]=y;
             bCoords+=2;
             var vertexBuffer = gl.createBuffer();
             if(!vertexBuffer){console.log('Failed to create the buffer object');return -1;}
             gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);//Binding the buffer object to target
             gl.bufferData(gl.ARRAY_BUFFER, b_coords, gl.STATIC_DRAW);//Write data into buffer
             var a_Position=gl.getAttribLocation(gl.program, 'a_Position');
             if(a_Position<0){
               console.log('Failed to get the storage location of a_Position inside click');
               return;
             }
             else{console.log('success getting the storage location of a_Position inside click');}
             gl.vertexAttribPointer(a_Position, 2, gl.FLOAT, false, 0, 0);
             gl.enableVertexAttribArray(a_Position);
             gl.clear(gl.COLOR_BUFFER_BIT);
             gl.drawArrays(gl.POINTS, 0, bCoords/2);
           }
         }


       function bDefine(ev,gl){
         if(bDefined==false){
           nBoundaryPts=bCoords/2;//number of vertices
           console.log('number of boundary vertices = '+nBoundaryPts);
           var vertexBuffer = gl.createBuffer();
           if(!vertexBuffer){console.log('Failed to create the buffer object');return -1;}
           gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);//Binding the buffer object to target
           gl.bufferData(gl.ARRAY_BUFFER, b_coords, gl.STATIC_DRAW);//Write data into buffer
           var a_Position=gl.getAttribLocation(gl.program, 'a_Position');
           if(a_Position<0){
             console.log('Failed to get the storage location of a_Position');
             return;
           }
           else{console.log('success getting the storage location of a_Position');}
           gl.vertexAttribPointer(a_Position, 2, gl.FLOAT, false, 0, 0);
           gl.enableVertexAttribArray(a_Position);
           gl.clear(gl.COLOR_BUFFER_BIT);
           gl.drawArrays(gl.LINE_LOOP, 0, nBoundaryPts);
         }
         bDefined=true;
       }
       function reDefine(ev, gl){
         gl.clear(gl.COLOR_BUFFER_BIT);
         bCoords=0;iCoords=0;nCoords=0;nBoundaryPts=0;nInteriorPts=0;nPts=0;
         bDefined=false;
       }

       function iPoints(ev, gl, iPointsTxt){
         nInteriorPts=parseInt(iPointsTxt.value);
         iCoords=nInteriorPts*2;
         nCoords=bCoords+iCoords;
         var leftMin=b_coords[0];//Minimum x boundary coordinate
         var botMin=b_coords[1];//Minimum y boundary coordinate
         var rightMax=b_coords[0];//Maximum x boundary coordinate
         var upMax=b_coords[1];//Maximum y boundary coordinate
         for(var k=0;k<bCoords;k+=2){
           if(b_coords[k]<leftMin)leftMin=b_coords[k];
           if(b_coords[k]>rightMax)rightMax=b_coords[k];
         }
         for(var k=1;k<bCoords;k+=2){
           if(b_coords[k]<botMin)botMin=b_coords[k];
           if(b_coords[k]>upMax)upMax=b_coords[k];
         }
         var n=0;
         while(n<iCoords){
         //Add the interior vertices to i_coords and n_coords one by one
           var newX=leftMin+(rightMax-leftMin)*Math.random();
           var newY=botMin+(upMax-botMin)*Math.random();
           var yThreshold = newY;
           var LHS=0, RHS=0;//no of intersection pts at the left and right
           t=bCoords-3;
           for(var b=1;b<=t;b+=2){//Traverse all edges except the last one
             var H;//Total y difference of upper and lower edge nodes
             var W;//Total x difference of upper and lower edge nodes
             var lH;//y difference between yThreshold and lower node
             var lW;//x difference between yThreshold and lower node
             var midX;//x coordinate of the intersection point
             if(b_coords[b]>=yThreshold && b_coords[b+2]<yThreshold){
               if(b_coords[b-1]<=newX && b_coords[b+1]<=newX){LHS+=1;}
               else if(b_coords[b-1]>=newX && b_coords[b+1]>=newX){RHS+=1;}
               else if(b_coords[b-1]<newX && b_coords[b+1]>=newX){
                 H=b_coords[b]-b_coords[b+2];
                 W=b_coords[b+1]-b_coords[b-1];
                 lH=yThreshold-b_coords[b+2];
                 lW=lH*W/H;
                 midX=b_coords[b+1]-lW;
                 if(midX<newX){LHS+=1;}else if(midX>=newX){RHS+=1;}
               }
               else if(b_coords[b-1]>=newX && b_coords[b+1]<newX){
                 H=b_coords[b]-b_coords[b+2];
                 W=b_coords[b-1]-b_coords[b+1];
                 lH=yThreshold-b_coords[b+2];
                 lW=lH*W/H;
                 midX=b_coords[b+1]+lW;
                 if(midX<newX){LHS+=1;}else if(midX>=newX){RHS+=1;}
               }
             }
             else if(b_coords[b]<yThreshold && b_coords[b+2]>=yThreshold){
               if(b_coords[b-1]<=newX && b_coords[b+1]<=newX){LHS+=1;}
               else if(b_coords[b-1]>=newX && b_coords[b+1]>=newX){RHS+=1;}
               else if(b_coords[b-1]<newX && b_coords[b+1]>=newX){
                 H=b_coords[b+2]-b_coords[b];
                 W=b_coords[b+1]-b_coords[b-1];
                 lH=yThreshold-b_coords[b];
                 lW=lH*W/H;//H shouldn't be zero
                 midX=b_coords[b-1]+lW;
                 if(midX<newX){LHS+=1;}else if(midX>=newX){RHS+=1;}
               }
               else if(b_coords[b-1]>=newX && b_coords[b+1]<newX){
                 H=b_coords[b+2]-b_coords[b];
                 W=b_coords[b-1]-b_coords[b+1];
                 lH=yThreshold-b_coords[b];
                 lW=lH*W/H;
                 midX=b_coords[b-1]-lW;
                 if(midX<newX){LHS+=1;}else if(midX>=newX){RHS+=1;}
               }
             }
           }
           //Traverse the last edge
           if(b_coords[1]>=yThreshold && b_coords[bCoords-1]<yThreshold){
             if(b_coords[0]<=newX && b_coords[bCoords-2]<=newX){LHS+=1;}
             else if(b_coords[0]>=newX && b_coords[bCoords-2]>=newX){RHS+=1;}
             else if(b_coords[0]<newX && b_coords[bCoords-2]>=newX){
               H=b_coords[1]-b_coords[bCoords-1];
               W=b_coords[bCoords-2]-b_coords[0];
               lH=yThreshold-b_coords[bCoords-1];
               lW=lH*W/H;
               midX=b_coords[bCoords-2]-lW;
               if(midX<newX){LHS+=1;}else if(midX>=newX){RHS+=1;}
             }
             else if(b_coords[0]>=newX && b_coords[bCoords-2]<newX){
               H=b_coords[1]-b_coords[bCoords-1];
               W=b_coords[0]-b_coords[bCoords-2];
               lH=yThreshold-b_coords[bCoords-1];
               lW=lH*W/H;
               midX=b_coords[bCoords-2]+lW;
               if(midX<newX){LHS+=1;}else if(midX>=newX){RHS+=1;}
             }
           }
           else if(b_coords[1]<yThreshold && b_coords[bCoords-1]>=yThreshold){
             if(b_coords[0]<=newX && b_coords[bCoords-2]<=newX){LHS+=1;}
             else if(b_coords[0]>=newX && b_coords[bCoords-2]>=newX){RHS+=1;}
             else if(b_coords[0]<newX && b_coords[bCoords-2]>=newX){
               H=b_coords[bCoords-1]-b_coords[1];
               W=b_coords[bCoords-2]-b_coords[0];
               lH=yThreshold-b_coords[1];
               lW=lH*W/H;//H shouldn't be zero
               midX=b_coords[b-1]+lW;
               if(midX<newX){LHS+=1;}else if(midX>=newX){RHS+=1;}
             }
             else if(b_coords[0]>=newX && b_coords[bCoords-2]<newX){
               H=b_coords[bCoords-1]-b_coords[1];
               W=b_coords[0]-b_coords[bCoords-2];
               lH=yThreshold-b_coords[1];
               lW=lH*W/H;
               midX=b_coords[0]-lW;
               if(midX<newX){LHS+=1;}else if(midX>=newX){RHS+=1;}
             }
           }
           console.log('LHS = '+ LHS);
           console.log('RHS = '+ RHS);
           if((LHS%2) == 1 && (RHS%2) == 1){
             i_coords[n]=newX;
             i_coords[n+1]=newY;
             n_coords[bCoords+n]=newX;
             n_coords[bCoords+n+1]=newY;
             console.log('newX is '+newX);
             console.log('newY is '+newY);
             n+=2;
           }
         }
         nBoundaryPts =bCoords/2;//Number of boundary vertices
         nPts = nInteriorPts+nBoundaryPts;//total number of vertices
         console.log('number of vertices = '+nPts);
         var vertexBuffer = gl.createBuffer();
         if(!vertexBuffer){console.log('Failed to create the buffer object');return -1;}
         gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);//Binding the buffer object to target
         gl.bufferData(gl.ARRAY_BUFFER, n_coords, gl.STATIC_DRAW);//Write data into buffer
         var a_Position=gl.getAttribLocation(gl.program, 'a_Position');
         if(a_Position<0){
           console.log('Failed to get the storage location of a_Position');
           return;
         }
         else{console.log('success getting the storage location of a_Position');}
         gl.vertexAttribPointer(a_Position, 2, gl.FLOAT, false, 0, 0);
         gl.enableVertexAttribArray(a_Position);
         gl.clear(gl.COLOR_BUFFER_BIT);
         console.log('nBoundaryPts = '+nBoundaryPts);
         console.log('nInteriorPts = '+nInteriorPts);
         console.log('nPts = '+nPts);
         console.log('bCoords = '+bCoords);
         console.log('nCoords = '+nCoords);
         console.log('n_coords looks like this: ');
         for(var z=0;z<nCoords;z+=2){console.log(n_coords[z]+' , '+n_coords[z+1]);}
         gl.drawArrays(gl.POINTS, nBoundaryPts, nInteriorPts);
         gl.drawArrays(gl.LINE_LOOP, 0, nBoundaryPts);
       }
   </script>

</body>
</html><p>The above canvas responds to mouse clicks by drawing a dot. Using mouse clicks the boundary of the domain to be meshed is defined. In the next step the interior of the boundary is populated with vertices with random position. In this process the random vertices are generated between the maximum and minimum x and y coordinates of the boundary vertices. In order to determine if a randomly generated vertex is inside the boundary or not, the following steps are applied [<a class="reference internal" href="#id1">1</a>]:</p>
<ul class="simple">
<li><strong>Step 1</strong>: For each newly generated interior vertex (test vertex), the y coordinate of this vertex is called the y-threshold. Find the edges constituting the boundary, which have one end above, the other end below the y-threshold. If one vertex of an edge is exactly on the y-threshold, then this vertex is assumed to be above the threshold. This is an arbitrary decision. If we choose the other way round it would work too as long as this rule is applied consistently.</li>
<li><strong>Step 2</strong>: Locate all points on the boundary where a straight horizontal line through the test vertex intersects the boundary. These are the points on the edges found in Step 1 having the same y-coordinate as the y-threshold. This can be done by interpolating between the two ends of the edge for the x coordinate that corresponds to the y-threshold. If the interpolated x-coordinate is less than the x-coordinate of the test vertex, then the intersection point is on the left hand side of the test vertex.</li>
<li><strong>Step 3</strong>: If both on the left and right hand side of the test vertex there are odd number of intersection points (like 3 and 3), then the test vertex is inside the polygon. If there are even number of intersection points on both sides, then it is outside the polygon.</li>
</ul>
<div class="section" id="auxiliary-functions">
<h2>Auxiliary Functions<a class="headerlink" href="#auxiliary-functions" title="Permalink to this headline">Â¶</a></h2>
<p><strong>Finding if a point lies to the left or right of a line</strong>:</p>
<p><strong>Finding the intersection point of two line segments</strong>: We start this procedure by determining if two segments intersect or not. This can be done by checking the orientation of the segments with respect to each other [<a class="reference internal" href="#id2">2</a>]. As an example the orientation of the segment <span class="math">\((p_1, p_2)\)</span> in Figure 1 with respect to the vertex <span class="math">\(p_3\)</span> is counterclockwise and <span class="math">\(((p_2-p_1) \Lambda (p_3 - p_2))\cdot \mathbf{k}&gt;0\)</span>. Similarly the orientation of the segment <span class="math">\((p_1, p_2)\)</span> with respect to the vertex <span class="math">\(p_4\)</span> is clockwise and <span class="math">\(((p_2-p_1) \Lambda (p_4 - p_2))\cdot \mathbf{k}&lt; 0\)</span>. Here the symbol <span class="math">\(\Lambda\)</span> denotes the cross product operation and <span class="math">\(\mathbf{k}\)</span> denotes a unit vector in the positive z-direction according to the right hand rule.</p>
<div class="figure align-center" id="twosegs">
<a class="reference internal image-reference" href="_images/Segments.JPG"><img alt="_images/Segments.JPG" src="_images/Segments.JPG" style="width: 457.5px; height: 257.5px;" /></a>
<p class="caption">Figure 1: Intersection of Segments</p>
</div>
<p>The necessary conditions for 2 segments oriented as in Figure 1, to intersect each other are:</p>
<p><strong>Condition1</strong>: <span class="math">\(p_3\)</span> and <span class="math">\(p_4\)</span> must have opposite orientation with respect to the segment <span class="math">\((p_1, p_2)\)</span>.</p>
<p><strong>Condition2</strong>: <span class="math">\(p_1\)</span> and <span class="math">\(p_2\)</span> must have opposite orientation with respect to the segment <span class="math">\((p_3, p_4)\)</span>.</p>
<p><strong>References</strong></p>
<p id="id1">[1] <a class="reference external" href="http://alienryderflex.com/polygon/">http://alienryderflex.com/polygon/</a></p>
<p id="id2">[2] <a class="reference external" href="http://www.geeksforgeeks.org/check-if-two-given-line-segments-intersect/">http://www.geeksforgeeks.org/check-if-two-given-line-segments-intersect/</a></p>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Polygon Meshing through Triangulation</a><ul>
<li><a class="reference internal" href="#auxiliary-functions">Auxiliary Functions</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="SiemensNX.html"
                        title="previous chapter">3D Modeling Tutorials</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="WebGL_DNBackShapes.html"
                        title="next chapter">Dual N-Back with Geometry and Tunes</a></p>
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="_sources/WebGL_Tri.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="WebGL_DNBackShapes.html" title="Dual N-Back with Geometry and Tunes"
             >next</a> |</li>
        <li class="right" >
          <a href="SiemensNX.html" title="3D Modeling Tutorials"
             >previous</a> |</li>
        <li><a href="index.html">Tensile Strain Capacity 1.0.2 documentation</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2014, Celal Cakiroglu.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.2.2.
    </div>
  </body>
</html>